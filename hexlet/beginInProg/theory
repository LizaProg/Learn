//тернарный оператор
access = (age > 14) ? true : false;

if (age > 14) {
  access = true;
} else {
  access = false;
}

const abs = n => (n >= 0 ? n : -n);

if(n >= 0){
return n
}else{
return -n
}


var message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

  if (age < 3) {
    message = 'Здравствуй, малыш!';
  } else if (age < 18) {
    message = 'Привет!';
  } else if (age < 100) {
    message = 'Здравствуйте!';
  } else {
    message = 'Какой необычный возраст!';
  }


4 типа ошибок:
1. Syntax error. Неверное использование языка. Часто лишние или недостающие скобки или кавычки. Что делать? Заменить, удалить или добавить символы. Часто проблема в скобках или кавычках: открытые скобки должны быть закрыты, открытые кавычки должны быть закрыты.
2. Reference error. Использование несуществующего названия. Что делать? Проверить, существует ли то, на что вы ссылаетесь. Возможно вы использовали ошибочное название или забыли его создать.
3. Type error. Использование неверного типа, например попытка вызвать константу числа, как функцию. Что делать? Убедиться, что всё используется верно. Часто проблема в простой путанице: вы создали численную константу и функциональную константу, а потом пытаетесь вызвать число. Вероятно вы собирались вызвать функцию.
4. Logic error. (Логическая ошибка) Ваш код выполняет не то, что требуется, но программа запускается и не выдаёт ошибок трёх перечисленных выше типов. Сломана логика. Что делать? Проверить свой код, убедиться, что он выполняет то, что должен.


AND (&&):

| A     | B     | A AND B |
| ----- | ----- | ------- |
| TRUE  | TRUE  | TRUE    |
| TRUE  | FALSE | FALSE   |
| FALSE | TRUE  | FALSE   |
| FALSE | FALSE | FALSE   |
OR (||):

| A     | B     | A OR B |
| ----- | ----- | ------ |
| TRUE  | TRUE  | TRUE   |
| TRUE  | FALSE | TRUE   |
| FALSE | TRUE  | TRUE   |
| FALSE | FALSE | FALSE  |
NOT (!):

| A     | NOT A |
| ----- | ----- |
| TRUE  | FALSE |
| FALSE | TRUE  |


//7 error

4 типа ошибок:
1. Syntax error. Неверное использование языка. Часто лишние или недостающие скобки или кавычки. Что делать? Заменить, удалить или добавить символы. Часто проблема в скобках или кавычках: открытые скобки должны быть закрыты, открытые кавычки должны быть закрыты.
2. Reference error. Использование несуществующего названия. Что делать? Проверить, существует ли то, на что вы ссылаетесь. Возможно вы использовали ошибочное название или забыли его создать.
3. Type error. Использование неверного типа, например попытка вызвать константу числа, как функцию. Что делать? Убедиться, что всё используется верно. Часто проблема в простой путанице: вы создали численную константу и функциональную константу, а потом пытаетесь вызвать число. Вероятно вы собирались вызвать функцию.
4. Logic error. (Логическая ошибка) Ваш код выполняет не то, что требуется, но программа запускается и не выдаёт ошибок трёх перечисленных выше типов. Сломана логика. Что делать? Проверить свой код, убедиться, что он выполняет то, что должен.


//8 рекурсия последняя задача
const sequenceSum = (begin, end) => {
  if(begin > end){
    return NaN;
  }
  else if(begin === end){
    return begin
  }
  else{
   return begin + sequenceSum(begin + 1, end);
  }
};


//9 итеративный процесс — вычисление с фиксированным количеством состояний.

Рекурсия — это когда что-то содержит себя в своём описании.
Рекурсивный процесс — это процесс обработки данных с отложенными вычислениями.
Итеративный процесс — это процесс вычисления, когда состояние может быть описано фиксированным количеством значений.

const smallestDivisor = (num) => {
  // BEGIN (write your solution here)
  const res;
  const previous = num - 1;
  if (num % 2 == 0){
    res = 2;
    return res;
  }else if(num % previous == 0){
    res = previous;
    return res;
  }else{
    return num  + " это простое число"
  }

  // END
};

export default smallestDivisor;


const iter = (acc) => {
    // We use 'num / 2' in the condition below, and not 'num'.
    // This is a simple optimization: a number cannot be divided
    // by a number larger than its half.
    if (acc > num / 2) {
      return num;
    }
    if (num % acc === 0) {
      return acc;
    }
    return iter(acc + 1);
  };

  return iter(2);

//10 переменные циклы
Циклы — это повторяющиеся блоки кода.
Цикл while — это блок, повторяющийся пока какое-то состояние истинно.
декларативная — она как бы определение (трактование, характеристика) факториала. Она декларирует, что такое факториал.
итеративная функция — императивная — описание того, что нужно делать, чтобы найти факториал.
Декларативное — это что. Императивное — это как.

//11 строки
1.строки являются неизменяемыми(Любые строковые функции, примененные к строкам, возвращают новую строку)
2.сравнивать строки с помощью > и <, и сравнение будет происходить именно лексикографически(алфавитный порядок)

3.Интерполяция с помощью backticks (``)
const name = "Alex;"
  const a = 10;
  const b = 12;
  console.log(`His name was ${name} and his age was ${a + b}`);
  Такой код выведет на экран His name was Alex; and his age was 22. Внутрь ${} вы можете поместить любое выражение.

4.управляющие символы \t — это табуляция, \n это перенос на новую строку

//12 for и ззменение переменных
Операторы инкрементирования и декрементирования:

// Postfix
let a = 3;
let b;
b = a++;    // b = 3, a = 4

// Prefix
let a = 3;
let b;
b = ++a;    // b = 4, a = 4


//
let answer;
if (num === 1) {
  answer = "One";
} else if (num === 2) {
  answer = "Two";
} else {
  answer = "Nothing";
}

switch(num) {
 case 1:  // if (num === 1)
    answer = "One";
    break;

  case 2:  // if (num === 2)
    answer = "Two";
    break;

  default:
    answer = "Nothing";
    break;
}

//пример цикла for
const factorial = (n) => {
  let result  = 1;

  // initialization↓    condition↓     update↓
  for (let counter = 1; counter <= n; counter++) {
    result *= counter;
  }

  return result;
}


//14
Поставьте export перед тем, что вы хотите экспортировать. Такая операция сделает это импортируемым куда угодно:

export const pi = 3.14;
export const e = 2.718;

export const square = (x) => {
  return x * x;
};

export const surfaceArea = (r) => {
  return 4 * pi * square(r);
};

Импортируйте специфичные штуки таким способом:

import { surfaceArea, square } from './math';

const surfaceOfMars = surfaceArea(3390);
const surfaceOfMercury = surfaceArea(2440);
const yearSquared = square(2017);
'./math' означает "из файла math.js, расположенного в той же (текущей) папке".

Или импортируйте всё:

import * as mathematics from './math';

const surfaceOfMars = mathematics.surfaceArea(3390);
const surfaceOfMercury = mathematics.surfaceArea(2440);
const yearSquared = mathematics.square(2017);
Это значит: "импортировать весь модуль и назвать его mathematics в этом модуле". Вот почему к импортированным сущностям обращение происходит через mathematics вот так: mathematics.surfaceArea.


//15
Перед выражением стоит четное количество знаков отрицания !. Например, !!!!A. Как можно упростить эту формулировку, не меняя смысла?
Убрать все знаки отрицания


Ниже приведены определения функций, предназначенных для решения одной и той же задачи - проверка целого числа на соответствие двум условиям: оно больше десяти (1) и при этом не равно двадцати пяти (2). Отметьте те варианты, которые правильно решают поставленную задачу:
(нужно выбрать все правильные ответы)

const isRightNum = num => (num >= 11) && (num !== 25); //да

const isRightNum = num => (num > 10) && (num !== 25); //да

const isRightNum = (num) => {
  const res = (num >= 10) && (num !== 25);
  return res;
};


//16

Окружение — это что-то вроде изолированной области кода.
Компоненты, созданные снаружи функций, инструкций с if, циклов и так далее, находятся в глобальном окружении
Фигрурные скобки { } задают новое локальное окружение
Область видимости компонентов — это местоположение, где эти компоненты доступны. Компоненты из глобального окружения имеют глобальную область видимости. Компоненты из локального окружения имеют локальную область видимости.

Лексическая область видимости
JavaScript пытается найти значение в текущем окружении. Но значение не находится и JavaScript выходит наружу, на один уровень за попытку, пока не найдёт значение или не понимает, что значение невозможно найти.
let a = 7;
let b = 10;

const multiplier = () => {
  let a = 5;
  return a * b;
}

multiplier(); // 50
Здесь, в выражении a * b , функция multiplier использует локальную a (потому что она обнаружена локально), и наружную b (потому что локально b найдена не была).

Замыкания
const createPrinter = () => {
  const name = "King";

  const printName = () => {
    console.log(name);
  }

  return printName;
}

const myPrinter = createPrinter();
myPrinter();    // King
myPrinter — это функция, которая была возвращена createPrinter. Несмотря на то, что вызов createPrinter окончен и константы name больше не существует, значение запомнено в myPrinter.

Это замыкание: сочетание функции и окружения, где она была заявлена.


Что будет выведено на экран
const x = 7;
const f = (x) => () => () => x;
console.log(f(10)()());

const f = (x) => () => () => x;
var f = function(x) {
    return function() {
        return function() {
            return x;
        }
    }
}

a = f(1)
b = a()
f(1)()()


//17

NaN означает "не число", но тип этого значения — number.

В JavaScript кроме undefined существует null. Оно означает, что «значение отсутствует». Например, если создать переменную, но не задавать ей значения, то у нее будет значение undefined:

let a;
console.log(a);     // undefined
Тут значения не оказалось ненамеренно. Видимо, просто еще не пришло время дать этой переменной значение.

null нужен для явного, намеренного указания, что значения нет. Можно сказать let a = null;. Например, вы попросили пользователя ввести информацию, но он ничего не ввел. В таком случае уместно записать в результат null.

null, в отличие от undefined, можно задавать вручную, передавать как аргумент в функцию и в целом использовать как любое другое явное значение.

При сравнении null и undefined нужно быть осторожным:

typeof null;          // "object" (не "null" по историческим причинам)
typeof undefined;     // "undefined"
null === undefined;   // false

null == undefined;    // true
null === null;        // true
null == null;         // true
!null;                // true

isNaN(1 + null);      //false
isNaN(1 + undefined); //true


В JavaScript есть расслабленное сравнение, с двумя знаками равенства. Они показывают, что происходит внутри JavaScript, когда он обрабатывает типизации:

1 === '1';    // false
1 == '1';     // true

true === 1;   // false
true == 1;    // true


//18

Детерминированная функция всегда возвращает одинаковое значение при определённом вводе (аргументы).

Недетерминированная функция не всегда будет возвращать одинаковое значение при определённом вводе.
Функция, которая возвращает погоду на данный момент для какой-нибудь координаты — недетерминированная: погода всегда меняется, поэтому мы не можем быть уверены, какой ответ выдаст функция.

Когда функция детерминированная и не имеет побочных эффектов, мы называем её "чистой" функцией.

Чистые функции:
проще читать
проще отлаживать
проще тестировать
не зависят от порядка, в котором они вызываются
просто запустить параллельно (одновременно)
Чистые функции независимы от времени. Недетерминизм и побочные эффекты добавляют понятие времени. Если функция зависит от чего-то, что может случиться, а может не случиться и меняет что-то за пределами своих границ, то она неожиданно становится зависимой от времени.




//???
Предназначение функции getIncreasedNumber - возвращать увеличенное в 10 раз значение. При этом значение коэффициента увеличения хранится во внешнем окружении функции, в переменной multiplier:

let multiplier = 10;

const getIncreasedNumber = num => num * multiplier;

getIncreasedNumber(7); // 70
getIncreasedNumber(7); // 70
multiplier = 5;
getIncreasedNumber(7); // 35
Какие выводы можно сделать из вышеприведённого кода? Выберите верные утверждения:

(нужно выбрать все правильные ответы)


Функция обладает побочными эффектами, т.к. взаимодействует с объектами во внешнем окружении


Вызов функции с одним и тем же аргументом может возвращать разные значения, поэтому она является детерминированной


Функция недетерминирована, т.к. результат её вычисления зависит от внешних данных (переменная multiplier)//да


Данную функцию нельзя назвать надёжной, возвращаемое ею значение непредсказуемо, а результат вызова функции нельзя закешировать //да


Выберите примеры недетерминированных функций

(нужно выбрать все правильные ответы)


функция подсчета площади на основе длины и ширины


функция, которая всегда возвращает число 42


функция, выводящая на экран степень загруженности улиц города в баллах (как Яндекс.Пробки)//да


identity-функция (она возвращает переданный ей аргумент)


функция, возвращающая произведение переданного аргумента и случайного числа от 1 до 3 //да